The following input was generated by the test harness and program. The program
was run in Cloud9.

INPUT FILE 1
Sorted in 2.7311965823173523e-05
Divide and Conquer:  2.8635642126552705
Runtime (DC): 9.502586908638477e-05
Brute Force:  2.8635642126552705
Runtime (BF): 0.0001928920391947031
Divide and conquer was 2.029889766326173 times faster.

INPUT FILE 2
Sorted in 0.0004494569730013609
Divide and Conquer:  10.613581958980673
Runtime (DC): 0.001018177019432187
Brute Force:  9.91036114377263          
Runtime (BF): 0.008503502933308482
Divide and conquer was 8.351694028657887 times faster.

INPUT FILE 3
Sorted in 0.1973516819998622
Divide and Conquer:  0.07858753081757049
Runtime (DC): 1.0279534759465605
Brute Force:  0.07858753081757049       
Runtime (BF): 93.41968875704333
Divide and conquer was 90.87929652752094 times faster.

INPUT FILE 4
Sorted in 1.3058025788050145
Divide and Conquer:  0.01664331697710184
Runtime (DC): 10.586506426800042
Brute Force Progress: 1.00% completeTimed out at 176.13492746511474 seconds.
At this rate, it would take 17437.181684118892 seconds to complete this operation.
Brute Force:  9999
Runtime (BF): 176.1349719031714
Divide and conquer was 16.63768620186927 times faster.

Note that because the fourth run timed out (I was unwilling to wait the requisite
five hours to see the program run to completion) the actual "speed factor" is
given as DC running 1647 imes faster (as estimated from running through just
one percent of the final dataset).

The theoretical runtime for this program is computed by summing the runtimes
of its constituent parts.
    (1)     The algorithm reads in the dataset. O(n)
    (2)     The dataset is parsed into a usable state. O(n).
    (3)     The dataset is sorted. Quicksort is implemented to achieve this, and
            runtimes for quicksort are given as part of the output. The average
            runtime for quicksort os O(nlog(n))
    (4a)    (Divide and Conquer) The plane is recursively divided into sections
            until you have subplanes that only contain two pairs of points.
            These two pairs are compared at the "base case," and the shortest
            distance between the two is returned. This operation is achieved
            in O(nlog(n)) time.
    (4b)    (Brute Force) Every point is compared to every other point, and
            the distances are all compared. This results in n^2 comparisons.
            Thus, this implementation runs in O(n^2) time.
            
    Brute Force: 2O(n) + O(nlog(n)) + O(n^2)
        implying an overall runtime of O(n^2).
    
    Divide and Conquer:  2O(n) + 2O(nlog(n))
        implying an overall runtime of O(nlog(n)).
        
Theoretically, Divide and Conquer will be the faster of the two. How do these
runtimes stack up to reality?

Set (1) contained 10 elements.
    Divide and Conquer completed its run in 9.50e-05 seconds.
        If DC runs at O(nlogn), then we can look at this as running in a time
        cnlogn =  9.50e-05, such that n = 10.
        This implies c is whereabouts of 4.1258e-06. We'll keep this in mind.
    Brute Force completed its run in in 19.29e-05 seconds.
        As above, BF runs in O(n^2). Taking the runtime to be cn^2 = 19.29e-05,
        we find c = 1.929*10^-6
    
Set (2) contained 100 elements.
    Based on values calculated for set (1), we might expect the runtimes for
    set (2) to be:
        DC:     0.0019 seconds  (0.001018 actual)
        BF:     0.01929 seconds (0.008504 actual)
        where the DC algorithm runs ~10 times faster.
    In fact, the data indicated that the DC algorithm ran 8.3 times faster than
    the BF algorithm. Not bad! Other factors can throw off the precision of this
    runtime estimate -- things like failing to account for prints and the fact
    that my Cloud9 instance is a cloud machine sharing CPU time with other users.
    Since this is a larger dataset, let's re-examine our values of c based
    on this dataset.
        c(dc) = 4.42112*10^-6
        c(bf) = 8.504*10^-7

Set(3) contains 10e5 (10000) elements. 
    Based on the previous c value, we expect:
        DC:     0.38 seconds  (01.028 actual)
        BF:     192.9 seconds (93.420 actual)
        where the DC algorithm runs ~500 times faster.
    The data indicates closer to 100 times faster. This is sensible, since there
    are a lot of "helper functions" running (timers, prints, writes, and so
    on) that affect runtime.
    
Set(4) contains 100,000 elements.
    Based on the previous c value, we expect:
        DC:     4.75 seconds  (10.587 actual)
        BF:     19290 seconds (17437 estimated)
    In this run, the brute force algorithm ran in a prohibitively long time. 
    An estimate had to be made of the projected runtime based on 1% completion
    of the run and assuming the rest of the run would take equally as long.
    Obviously, the DC algorithm shines in this much larger test case. It runs in
    1/1600th of the time of the brute force algorithm.